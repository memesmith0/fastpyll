;fastpyll_c_brief.scm gplv2 found at gnu.org john morris beck this program is intended to be a template for a dialect of lisp to make c easier to program in for new and experienced programmer. it is intentionally omitting some parts of c for berevity. it is possible to add garabge collection into vanilla c. it is possibile to write this entirely in fastlisp. what comes after fastpyll is a mit-scratch-like program that compiles to scheme or to fastlisp. what comes after that is a vr version of legos that works like mit scratch. what comes after that is non euclidian legos.
(use-modules (ice-9 textual-ports) (ice-9 eval-string))
(define-syntax l (syntax-rules () ((l (params ...) body ...) (lambda (params ...) body ...)) ((l (params ... . rest-arg) body ...) (lambda (params ... . rest-arg) body ...))))
(define-syntax d (syntax-rules () [(_ variable value) (define variable value)]))
(d sa string-append)
(d w length)
(d s string?)
(d t list?)
(d e eq?)
(d find (l (x) (if (= x 0) "" (sa " " " " " " " " (find (- x 1))))))
(d fh (l (d x) (if (pair? x) (sa (find d) (car x) ";\n\n" (fh d (cdr x))) (sa (find d) "}"))))
(d fstrcth (l (d x) (if (pair? x) (sa (find d) (car x) ";\n\n" (fstrcth d (cdr x))) (sa (findnt d) ""))))
(d fcb (l (d x . y) (sa x ":\n\n" (fh d y))))
(d fstar (l (x) (sa "*" x)))
(d fassgn (l (x y) (sa x " = " y)))
(d fpgroup (l (left right . x) (apply sa (append (list left) (farg x) (list right )))))
(d fgrp (l (x) (sa "(" x ")")))
(d farg (l (. x) (if (= (w x) 1) (car x) (if (> (w x) 1) (sa (car x) " , " (apply farg (cdr x)))""))))
(d farra (l (. x) (apply fpgroup (list "{ " " }" (apply farg x)))))
(d fdot (l (b . x) (sa b "." x)))
(d fdot_h (l (x) (sa "." (if (> (w x) 0) (car x) "")  (if (> (w x) 1) (fdot_h (cdr x)) ""))))
(d farr (l (b . x) (sa b (fdot_h x))))
(d fop (l (op x y) (sa "( " x " " op " " y " )")))
(d fnot (l (x) (sa "!(" x ")")))
(d fstrct (l (d x a . y) (sa "struct " x " {\n\n" (fstrcth d y) "} " a " ;")))
(d fd (l (d x a . y) (sa x "( " (apply farg (if (eq? a "") (list) a)) " ) {\n\n" (fh d y))))
(d fwle (l (d x . y) (sa "while( " x " ) {\n\n" (fh d y))))
(d fwiz (l (a d . y) (sa "switch( " a " ) {\n\n" (fh d y))))
(d fcase (l (a d . y) (sa "case " a " :\n\n" (fh d y))))
(d flitadd (l (x) (sa "&" x)))
(d ftyp (l (type x) (sa type " " x)))
(d fd (l (d x a . y) (sa x "( " (apply farg (if (eq? a "") (list) a)) " ) {\n\n" (fh d y))))
(d fstr (l (x) (sa "\"" x "\"")))
(d fcfs  (l (x) (if (and (symbol? (car x)) (or (eq? (car x) 'fd) (eq? (car x) 'fwle) (eq? (car x) 'fstrct))) #t #f)))
(d fsfi (l (b g x) (cond
		    ((and b (t x) (not (> (w x) 0))) "")
		    ((and b (t (car x)) (> (w x) 1)) (append (list (fsfi #t g (car x))) (let ((foo (fsfi #f g (cdr x)))) (if (t foo) foo (list foo)))))
		    ((and (not b) (t (car x)) (> (w x) 1)) (append (list (fsfi #t g (car x))) (let ((foo (fsfi #f g (cdr x)))) (if (t foo) foo (list foo)))))
		    ((and  b (not (t (car x))) (> (w x) 1)) (append (list (car x)) (let ((foo (fsfi #f g (cdr x)))) (if (t foo) foo (list foo)))))
		    ((and b (t (car x)) (not (> (w x) 1))) (list (fsfi #t g (car x))))
		    ((and (not b) (not (t (car x))) (> (w x) 1)) (append (list (cond ((s (car x)) (fstr (car x))) ((symbol? (car x)) (symbol->string (car x))) ((number? (car x)) (number->string (car x))))) (let ((foo (fsfi #f g (cdr x)))) (if (t foo) foo (list foo)))))
		    ((and (not b) (t (car x)) (not (> (w x) 1)))(list (fsfi #t g (car x))))
		    ((and  b (not (t (car x))) (not (> (w x) 1))) x)
		    ((and (not b) (not (t (car x))) (not (> (w x) 1))) (cond ((s (car x)) (fstr (car x)))((symbol? (car x)) (symbol->string (car x)))((number? (car x)) (number->string (car x))))))))
(d faddind (l (b g x) (cond
		       ((and b (t (car x)) (> (w x) 1)) (append (list (faddind #t g (car x))) (let ((foo (faddind #f g (cdr x)))) (if (t foo) foo (list foo)))))
		       ((and (not b) (t (car x)) (> (w x) 1)) (append (list (faddind #t g (car x))) (let ((foo (faddind #f g (cdr x)))) (if (t foo) foo (list foo)))))
		       ((and  b (not (t (car x))) (> (w x) 1)) (append (list (car x)) (if (fcfs x) (append (list g) (let ((foo (faddind #f (+ g 1) (cdr x)))) (if (t foo) foo (list foo)))) (let ((foo (faddind #f g (cdr x)))) (if (t foo) foo (list foo))))))
		       ((and b (t (car x)) (not (> (w x) 1)))(list (faddind #t g (car x))))
		       ((and (not b) (not (t (car x))) (> (w x) 1)) (append (list (car x)) (let ((foo (faddind #f g (cdr x)))) (if (t foo) foo (list foo)))))
		       ((and b (t (car x)) (not (> (w x) 1))) (list (faddind #t g (car x))))
		       ((and (not b) (not (t (car x))) (> (w x) 1)) (append (list (car x)) (let ((foo (faddind #f g (cdr x)))) (if (t foo) foo (list foo)))))
		       ((and (not b) (t (car x)) (not (> (w x) 1))) (list (faddind #t g (car x))))
		       ((and  b (not (t (car x))) (not (> (w x) 1))) x)
		       ((and (not b) (not (t (car x))) (not (> (w x) 1))) (car x)))))
(d fisprim (l (s) (cond ((eq? s 'modulo) 'fmod) ((eq? s 'dereference) 'fstar) ((eq? s 'prefix) 'ftyp) ((eq? s 'assign) 'fassgn) ((eq? s 'group)  'fgrp) ((eq? s 'array) 'farra) ((eq? s 'access) 'fdot) ((eq? s 'switch) 'fwiz) ((eq? s 'case) 'fcase) ((eq? s 'operate) 'fop) ((eq? s 'while) 'fwle) ((eq? s 'define) 'fd) ((eq? s 'struct) 'fstrct) ((eq? s 'case) 'fcase)  ((eq? s 'address) 'flitadd) (#t 'foop))))
(d fprc (l (ra . y) (sa ra "( " (apply farg y) " )")))
(d faddpre (l (ra) (if (eq? ra 'list) (list ra) (let* (( fsymbol (fisprim ra))) (if (not (eq? fsymbol 'foop)) (list fsymbol) (list 'fprc (symbol->string ra)))))))
(d fchgnm (l (b g x) (cond
		      ((and b (t (car x)) (> (w x) 1)) (append (list (fchgnm #t g (car x))) (let ((foo (fchgnm #f g (cdr x)))) (if (t foo) foo (list foo)))))
		      ((and (not b) (t (car x)) (> (w x) 1))(append (list (fchgnm #t g (car x))) (let ((foo (fchgnm #f g (cdr x))))(if (t foo) foo (list foo)))))
		      ((and  b (not (t (car x))) (> (w x) 1)) (append (faddpre (car x)) (append (let ((foo (fchgnm #f g (cdr x)))) (if (t foo) foo (list foo))))))
		      ((and b (t (car x)) (not (> (w x) 1))) (list (fchgnm #t g (car x))))
		      ((and (not b) (not (t (car x))) (> (w x) 1)) (append (list (car x)) (let ((foo (fchgnm #f g (cdr x)))) (if (t foo) foo (list foo)))))
		      ((and (not b) (t (car x)) (not (> (w x) 1))) (list (fchgnm #t g (car x))))
		      ((and  b (not (t (car x))) (not (> (w x) 1))) (faddpre (car x)))
		      ((and (not b) (not (t (car x))) (not (> (w x) 1))) (car x)))))
(d fstrprcl (l (ra . y) (sa ra "( " (apply farg y) " )")))
(d faddpre2str (l (ra) (if (s ra) (list 'fstrprcl ra) ra)))
(d fstrapp (l (b g x)(cond
		      ((and b (t (car x)) (> (w x) 1))(let ((bar (fstrapp #t g (car x)))) (if (s bar) (fstrapp #t g (append(faddpre2str bar)(cdr x))) (append (let ((foo (fstrapp #f g (cdr x)))) (if (t foo) foo (list foo)))))))
		      ((and (not b) (t (car x)) (> (w x) 1)) (append (list (fstrapp #t g (car x))) (let ((foo (fstrapp #f g (cdr x)))) (if (t foo) foo (list foo)))))
		      ((and  b (not (t (car x))) (> (w x) 1))(apply (eval (car x) (interaction-environment)) (append (let ((foo (fstrapp #f g (cdr x)))) (if (t foo) foo (list foo))))))
		      ((and b (t (car x)) (not (> (w x) 1))) (let ((bar (fstrapp #t g (car x)))) (if (s bar) (fstrapp #t g (append (faddpre2str bar))) (list (fstrapp #t g (car x))))))
		      ((and (not b) (not (t (car x))) (> (w x) 1))(append (list (car x)) (let ((foo (fstrapp #f g (cdr x)))) (if (t foo) foo (list foo)))))
		      ((and (not b) (t (car x)) (not (> (w x) 1))) (list (fstrapp #t g (car x))))
		      ((and  b (not (t (car x))) (not (> (w x) 1))) (apply (eval (car x) (interaction-environment)) (list)))
		      ((and (not b) (not (t (car x))) (not (> (w x) 1))) (car x)))))
(d fhlp (l (x) (sa (fstrapp #t 1 (faddind #t 1 (fchgnm #t 1 (fsfi #t 1 x)))) "\n\n")))
(d fc (l (x) (apply sa (map fhlp x))))
(display (fc '((prefix include "<stdio.h>") (prefix int (operate = f 7)) (prefix int (define main () (print "hi") (print "bye"))))))
